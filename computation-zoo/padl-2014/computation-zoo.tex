\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{semantic}
\usepackage{verbatim}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{breakurl}

\begin{document}

\title{The F\# Computation Expressions Zoo}
\author{Tomas Petricek\inst{1} \and Don Syme\inst{2}}
\institute{University of Cambridge, UK\and Microsoft Research Cambridge, UK \\
\textsf{tp322@cam.ac.uk}, \textsf{dsyme@microsoft.com}}


\maketitle

% ==================================================================================================

\newcommand{\sep}[0]{\; | \;}
\newcommand{\kvd}[1]{\textnormal{\bfseries\sffamily #1}}
\newcommand{\plc}[1]{\textnormal{\emph{#1}}}
\newcommand{\ident}[1]{\textnormal{\sffamily #1}}

\newcommand{\cexpr}{\plc{cexpr}}
\newcommand{\expr}{\plc{expr}}
\newcommand{\binds}{\plc{binds}}
\newcommand{\pat}{\plc{pat}}

% Computation types
\newcommand{\mtyp}[1]{M #1}
\newcommand{\ntyp}[1]{N #1}
\newcommand{\ltyp}[1]{L #1}
\newcommand{\dtyp}[1]{D #1}

% Typing rules etc.
\newcommand{\tya}[2]{#1\hspace{-0.15em}:\hspace{-0.15em}#2}
\newcommand{\cvdash}{\Vdash_\sigma}
\newcommand{\bvdash}{\vartriangleright_\sigma}
\newcommand{\unit}{\ident{unit}}

% Translation rules
\newcommand{\tsl}[1]{|[ #1 |]_m}
\newcommand{\tsb}[1]{\langle\hspace{-0.25em}\langle #1 \rangle\hspace{-0.25em}\rangle_m}
\newcommand{\tsv}[1]{\langle #1 \rangle}

% ==================================================================================================

\begin{abstract}
Many computations can be structured using abstract types such as monoids, monad transformers or 
applicative functors. Functional programmers use those abstractions directly, but main-stream
languages often integrate concrete instances as language features -- e.g. generators in Python
or asynchronous computations in C\# 5.0. The question is, is there a sweet spot between convenient 
but inflexible language feature and flexible, but more difficult to use library?

\quad F\# \emph{computation expressions} answer this question in affirmative. Unlike 
the do notation in Haskell, computation expressions are not tied to a single kind of abstraction.
They support a wide range of computations, depending on what operations are available. They also 
provide greater syntactic flexibility leading to a more intuitive syntax.

\quad We show that computation expressions can structure well-known computations such as monoidal 
list comprehensions, monadic parsers, applicative formlets and asynchronous sequences based on the 
list monad transformer. We also present typing for computation expressions that is capable of 
capturing all these applications.
\end{abstract}

% ==================================================================================================

\section{Introduction}
Structures like monads [1] provide a way for composing computations with additional features. 
There are many examples -- monads can be composed using monad transformers [2], applicative
functors provide a more general abstraction useful for web programming [3] and additive monads
are useful for parsers [4].

In Haskell, we can write such computations using a mix of combinators and syntactic extensions like 
monad comprehensions [19] and do notation. On the other hand, languages such as Python and C\# 
emphasize the syntax and provide single-purpose support for asynchrony [20] and list generators [11]. 

We believe that syntax matters -- a language should provide \emph{uniform} syntactic support that 
can capture different abstractions, but is \emph{adaptable} and enables appropriate syntax depending
on the abstraction. This paper shows that F\# computation expressions provide such mechanism.

Although the technical aspects of the feature have been described before\footnote{F\# 3.0 extends the 
mechanism further to accomodate extensible query syntax. To keep this paper focused, we leave analysis 
of these extensions to future work.} [17], this paper is novel in that it relates the mechanism to 
well-known abstract computations. We also present new typing based on those uses.

\subsubsection{Practical examples.} 
We demonstrate the breath of computations that can be structured using F\# computation expressions.
The applications include asynchronous workflows and sequences \S\ref{sec:intro-async}, 
\S\ref{sec:intro-asyncseq}, list comprehensions and monadic parsers \S\ref{sec:intro-seq-parsers}
and formlets for web programming \S\ref{sec:intro-formlets}.

\vspace{-1em}
\subsubsection{Abstract computations.} We show that the above examples fit well-known types
of abstract computations, including additive monads and monad transformers, and we show what 
syntactic equalities hold as a result \S\ref{sec:laws}.

\vspace{-1em}
\subsubsection{Syntax and typing.} We revisit the definitions of computation expressions. We provide
typing rules that capture idiomatic uses \S\ref{sec:semantics-typing}, extend the translation
to support applicative functors \S\ref{sec:applicative} and discuss the threatment of effects
\S\ref{sec:semantics-delayed} that is needed in impure language.

\vspace{1em}
\noindent
We believe that software artifacts in programming language research matter [99], so all examples 
with implementations can be found and interactively run online: \url{http://tryjoinads.org/computations}. 
The syntax for applicative functors is a reserch extension; all other examples can be 
compiled with F\# 2.0.

% ==================================================================================================

\section{Computation expressions by example}
\label{sec:intro}

Computation expressions are blocks of code that represent computation with some non-standard 
aspect such as laziness, asynchronous evaluation, hidden state or other. The code inside the
block is re-interpreted using \emph{computation builder}, which is a record of operations that 
define the computation. It also defines what syntax is available in the block\footnote{The focus 
of this paper is \emph{not} on computation expressions, but on their relation to well-known 
abstractions. Readers unfamiliar with F\# may find extended explanation of the mechanism 
in previous publications [99,9].}.

Computation expressions mirror the standard F\# syntax (let binding, loops, exception handling),
but support additonal computational constructs. For example \ident{let!} represents computational 
(monadic) alternative of let binding.

We first introduce the syntax and mapping to the underlying operations, but both are made precise 
later \S\ref{sec:semantics}. To show the breadth of applications, we look at five examples arising 
from different abstract computations.

% --------------------------------------------------------------------------------------------------

\subsection{Monadic asynchronous workflows}
\label{sec:intro-async}

Asynchronous workflows [99] allow writing non-blocking I/O using a mechanism based on the 
\emph{continuation monad} (with error handling etc.) The following example shows F\# version
with an equivalent C\# code using single-purpose feature:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{getLength}~url=\ident{async}~\{\\
\quad \kvd{let!}~html = \ident{fetchAsync}~url\\
\quad \kvd{do!}~\ident{Async}.\ident{Sleep}~1000\\
\quad \kvd{return}~html.\ident{Length}\\
\}
\end{array}\qquad
\begin{array}{l}
\kvd{async}~\ident{Task}\langle\ident{string}\rangle~\ident{GetLength}(\kvd{string}~url)~\{\\
\quad \kvd{var}~html = \kvd{await}~\ident{FetchAsync}(url);\\
\quad \kvd{await}~\ident{Task}.\ident{Delay}(1000);\\
\quad \kvd{return}~html.\ident{Length};\\
\}
\end{array}
\end{equation*}

Both functions return a computation that expects a \emph{continuation} and then downloads a given 
URL, waits one second and passes content length to the continuation. The C\# version uses the built-in
$\ident{await}$ keyword to represent non-blocking waiting. In F\#, the computation is enclosed
in the $\ident{async}~\{ \ldots \}$ block, where \ident{async} is an identifier that refers to
the computation builder. 

Depending on the operations provided by the builder, different pre-defined keywords are allowed
in the computation block. The previous snippet uses \ident{let!} which represents (monadic) 
composition and requires the \emph{Bind} operation. This operation also enables the \ident{do!} 
keyword which is equivalent to using \ident{let!} on an unit-returning computation. Finally, the 
\ident{return} keyword is mapped to the \emph{Return} operation, so the previous F\# snippet is 
translated as follows:
%
\begin{equation*}
\begin{array}{l}
\ident{async}.\ident{Bind}(\ident{fetchAsync}(url), \kvd{fun}~html\rightarrow\\
\qquad \ident{async}.\ident{Bind}(\ident{Async}.\ident{Sleep}~1000, \kvd{fun}~()\rightarrow\\
\qquad\qquad \ident{async}.\ident{Return}(html.\ident{Length})))
\end{array}
\end{equation*}
%
The two operations form a monad and have the standard types. Assuming $A\tau$ is a type of asynchronous 
computations, the $\emph{Return}$ has a type $\alpha \rightarrow A\alpha$ and the required type of
$\emph{Bind}$ is $A\alpha \rightarrow (\alpha \rightarrow A\beta) \rightarrow A\beta$ (as a convention,
we use $\alpha, \beta$ for universally qualified type variables and $\tau$ as for concrete types)
\footnote{For the purpose of this paper, we write type application using a light notation $T\tau$. }.

\vspace{-1em}
\subsubsection{Sequencing and effects.} Primitive effectful expressions in F\# return \ident{unit}.
Assuming $e_1$ returns \ident{unit}, we can sequence expression using $e_1; e_2$ and we can also
write effectful \ident{if} condition without the \ident{else} clause (which implicitly returns
the unit value in the \ident{false} case). Both of these constructs have their equivalent 
in the computation expression syntax:
%
\begin{equation*}
\begin{array}{l}
\ident{async}~\{~ \kvd{if}~delay~\ident{then}~\kvd{do!}~\ident{Async}.\ident{Sleep}(1000)\\
\hspace{3.4em}     \ident{printfn}~ \texttt{"Starting..."}\\
\hspace{3.4em}     \kvd{return!}~ \ident{asyncFetch}(url) ~\}
\end{array}
\end{equation*}
%
If $delay$ is true, the workflow waits one second before downloading page and returning it.
For monads, it is possible to translate the snippet above using just \emph{Bind} and \emph{Return}, 
but this approach does not work for other computations \S\ref{sec:intro-seq-parsers}. For this reason, 
F\# requires additional operations -- \emph{Zero} represents monadic unit value, \emph{Combine} 
corresponds to the ``;'' operator and \emph{Delay} takes an effectful computation and embeds the 
effects in a (delayed) computation. 

Finally, the \ident{return!} keyword is used to return the result of a computation. 
It requires an operation \emph{ReturnFrom} of type $A\alpha \rightarrow A\alpha$. This is typically
implemented as an identity function -- its main purpose is to enable the \ident{return!} keyword in 
the syntax, as this may not be alway desirable \S\ref{sec:intro-seq-parsers}.
%
\begin{equation*}
\begin{array}{l}
\ident{async}.\ident{Delay}(\kvd{fun}~() \rightarrow \ident{async}.\ident{Combine}( \\
\quad\quad (~~\,\kvd{if}~delay~\kvd{then}~
   \ident{async}.\ident{Bind}(\ident{Async}.\ident{Sleep}(1000), \kvd{fun}~() \rightarrow \ident{async}.\ident{Zero}())\\
\quad\quad ~~~\,\kvd{else}~\ident{async}.\ident{Zero}()~),\\
\quad\quad \ident{async}.\ident{Delay}(\kvd{fun} () \rightarrow\\
\quad\quad\quad \ident{printfn}~\texttt{"Starting..."}\\
\quad\quad\quad \ident{async}.\ident{ReturnFrom}(\ident{asyncFetch}(url))) ))
\end{array}
\end{equation*}
%
The \emph{Zero} operation has a type $\ident{unit} \rightarrow A\,\ident{unit}$. It is inserted
when a computation does not return a value -- here, in both branches of the conditional. The
result of conditional is composed with the rest of the computation using \emph{Combine} which has
a type $A\,\ident{unit} \rightarrow A\alpha \rightarrow A\alpha$. The first argument is a unit-returning
computation, which mirrors the ``;'' operator -- the overall computation runs the left-hand side and
then returns the result of the right-hand side.

Finally, the \emph{Delay} operation (of type $(\ident{unit} \rightarrow A\tau) \rightarrow A\tau$ is
used to wrap any effectful computations (like printing) in the monadic computation to avoid evaluating
them before the first part of sequential computation is run.

% --------------------------------------------------------------------------------------------------

\subsection{Additive parsers and list comprehensions}
\label{sec:intro-seq-parsers}

An asynchronous workflow returns only \emph{one} value, but parsers or list comprehensions may return 
multiple values. Such computations can be structured using additive monads (\ident{MonadPlus} in 
Haskell). These abstractions can be used with F\# computation expressions, but they require different
typing of \emph{Zero} and \emph{Combine}. It may be also desirable to use different syntax.

\vspace{-1em}
\subsubsection{Monadic parsers.} For monadic parsers, we use a notation similar to the one used in
asynchronous workflows. The difference is that we can now use \ident{return} and \ident{return!} 
repeatedly. The following parsers recognize one or more and zero or more repetitions of a given
predicate, respectively:
%
\vspace{-0.5em}\begin{equation*}
\hspace{-2em} \begin{array}{l}
\kvd{let rec}~\ident{zeroOrMore}~p = \ident{parse}~\{\\
\quad \kvd{return!}~\ident{oneOrMore}~p\\
\quad \kvd{return}~[\,] ~\}
\end{array}
\qquad
\begin{array}{l}
\kvd{and}~\ident{oneOrMore}~p = \ident{parse}~\{\\
\quad \kvd{let!}~x=p\\
\quad \kvd{let!}~xs = \ident{zeroOrMore}~p\\
\quad \kvd{return}~x::xs ~\}
\end{array}
\vspace{-0.5em}
\end{equation*}
%
The \ident{oneOrMore} function uses just the monadic interface and so its translation uses 
\emph{Bind} and \emph{Return}. The \ident{zeroOrMore} function is more interesting -- it combines
a parser that returns one or more occurrences with a parser that always succeeds and returns an empty 
list. This is achieved using the \emph{Combine} operation:
%
\begin{equation*}
\begin{array}{l}
\kvd{let rec}~\ident{zeroOrMore}~p = \ident{parse}.\ident{Delay}(\kvd{fun}~()\rightarrow \\
\quad \ident{parse}.\ident{Combine}(~\ident{parse}.\ident{ReturnFrom}(\ident{oneOrMore}~p), \\
\hspace{7.8em} \ident{parse}.\ident{Delay}(\kvd{fun} () \rightarrow \ident{parse}.\ident{Return}(\,[\,]\,)~)))
\end{array}
\end{equation*}
%
The \emph{Combine} operation represents the monoidal operation on parsers (either left-biassed or
non-deterministic choice) and it has a type $P\alpha \rightarrow P\alpha \rightarrow P\alpha$. Accordingly,
the \emph{Zero} operations is the unit of the monoid. It represents a parser that always fails (returning
no values of type $\alpha$) and has a type $\ident{unit}\rightarrow P\alpha$.

For effectful sequencing of monads, it only makes sense to use unit-returning values in the left hand
side of \emph{Combine} and as the result of \emph{Zero}. However, if a computation supports the monoidal
interface, these operations can combine multiple returned values. This shows that the computation 
expression mechanism needs certain flexibility -- although the translation is the same in both cases,
the typing needs to depend on the user-defined types of the operations.

\vspace{-1em}
\subsubsection{List comprehensions.} Although list comprehensions implement the same abstract type
as parsers, we need to use different syntax if we want to make the syntactic sugar comparable to 
built-in features in other languages. The following shows F\# list comprehension and Python generator
side-by-side:

\begin{equation*}
\hspace{-2em}
\begin{array}{l}
\kvd{let}~\ident{duplicate}(list) = \ident{seq}~\{\\
\quad \kvd{for}~n~\kvd{in}~list~\kvd{do}  \\
\quad\quad \kvd{yield}~n          \\
\quad\quad \kvd{yield}~n*10 ~\}
\end{array}
\qquad\qquad
\begin{array}{l}
\kvd{def}~\ident{duplicate}(list):\\
\quad \kvd{for}~n~\kvd{in}~list:  \\
\quad\quad \kvd{yield}~n          \\
\quad\quad \kvd{yield}~n*10
\end{array}
\end{equation*}
%
The computations look very similar -- they iterate over a source list and produce two results
for each input. In contrast, Haskell monad comprehensions [19] allow us to write $[\;n*10\;|\;n\leftarrow list\;]$
to multiply all elements by 10, but they are not expressive enough to capture duplication. To do 
that, the code needs to use the monoidal operation (\ident{mplus}), but that cannot be done
inside comprehensions.

Although the F\# syntax looks different to what we have seen so far, it is actually very
similar. The \ident{for} and \ident{yield} constructs are translated to \emph{For} and 
\emph{Yield} operations which have the same form as \emph{Bind} and \emph{Return}, but provide
backing for a different syntax. The translation looks as follows:
%
\begin{equation*}
\begin{array}{l}
\ident{seq}.\ident{Delay}(\kvd{fun}~() \rightarrow \ident{seq}.\ident{For}(list, \kvd{fun}~() \rightarrow \\
\quad \ident{seq}.\ident{Combine}(\ident{seq}.\ident{Yield}(n), \ident{seq}.\ident{Delay}(\kvd{fun}~() \rightarrow 
   \ident{seq}.\ident{Yield}(n * 10)))~))
\end{array}
\end{equation*}
%
The \emph{Combine} operation concatenates multiple results and has the standard monoidal type
$[\alpha] \rightarrow [\alpha] \rightarrow [\alpha]$. The type of \emph{For} is that of monadic 
binding $[\alpha] \rightarrow (\alpha \rightarrow [\beta]) \rightarrow [\beta]$ and \emph{Yield} has a
type of monadic unit $\alpha \rightarrow [\alpha]$. We could have provided the \emph{Bind} 
and \emph{Return} operations in the \ident{seq} builder instead, but this leads to a less intuitive
syntax that requires users to write \ident{let!} for iteration and \ident{return} for yielding.

As the Python comparison shows, the flexibility of computation expressions means that they
are often close to built-in language features. The author of a concrete computation (\ident{parse}, 
\ident{seq}, \ident{async}, \ldots) decides what syntax is appropriate. We can only provide 
anecdotal recommendation -- for computations where the \emph{monoidal} interface is more important, 
the \ident{for}/\ident{yield} notation fits better, while for computations where
the \emph{monadic} interface dominates we prefer \ident{let!} and \ident{return}.

% --------------------------------------------------------------------------------------------------

\subsection{Layered asynchronous sequences}
\label{sec:intro-asyncseq}

It is often useful to combine non-standard aspects of multiple computation types. Abstractly,
this has be described using monad transformers [99]. F\# does not support monad transformers directly, 
but they provide a useful conceptual framework. For example, we migth combine 
non-blocking execution of asynchronous workflows with the ability to return multiple results in 
list comprehensions -- a file download can then produce data in 1kB buffers as they become available. 
Such computation is captured by \emph{asynchronous sequences} [14].

Assuming $\ident{Async}\,\tau$ is the type of asynchronous workflows, the composed
computation can be expressed as follows (inspired by the list transformer [99]):

\begin{equation*}
\begin{array}{lcl}
\kvd{type}~\ident{AsyncSeqInner}\,\tau &~=~& \ident{AsyncNil} ~|~
    \ident{AsyncCons}~\kvd{of}~\tau \times \ident{Async}\,\tau \\
\kvd{type}~\ident{AsyncSeq}\,\tau &=& \ident{Async}\,(\ident{AsyncSeqInner}\,\tau)
\end{array}
\end{equation*}

When provided with a continuation, asynchronous sequence calls it with either \ident{AsyncNil}
(to denote the end of the sequence) or with \ident{AsyncCons} that carries a value, together with
the rest of the asynchronous sequence. It turns out that the flexibility of computation expression 
makes it possible to provide an elegant syntax for writing computations of this type:
%
\begin{equation*}
\begin{array}{l}
\kvd{let rec}~\ident{urlPerSecond}~n = \ident{asyncSeq}~\{ \\
\quad \kvd{do!}~\ident{Async}.\ident{Sleep}~1000 \\
\quad \kvd{yield}~\ident{getUrl}~i \\
\quad \kvd{yield!}~\ident{iterate}~(i+1) ~\}
\end{array}
\qquad
\begin{array}{l}
\kvd{let}~\ident{pagePerSecond}~urls = \ident{asyncSeq}~\{ \\
\quad \kvd{for}~url~\kvd{in}~\ident{urlPerSecond}~0~\kvd{do}\\
\quad\quad \kvd{let!}~html = \ident{asyncFetch}~url \\
\quad\quad \kvd{yield}~url, html ~\}
\end{array}
\end{equation*}
%
The \ident{urlPerSecond} function creates an asynchronous sequence that produces one URL per
second. It uses bind (\ident{do!}) of the asynchronous workflow monad to wait one second
and then composition of asynchronous sequences, together with \ident{yield} to produce the 
next URL. The \ident{pagePerSecond} function uses \ident{for} to iterate over (bind on) an
asynchronous sequence and then \ident{let!} to wait for (bind on) an asynchronous workflow.
The \ident{for} loop is asynchronous and lazy -- it is run each time the caller asks for the 
next result.

Asynchronous sequences form a monad and so we could use the standard notation for monads with
just \ident{let!} and \ident{return}. We would then need explicit lifting function that turns
an asynchronous workflow into an asynchronous sequence that returns a single value. However,
F\# computation expressions allow us to do better. We can define both \ident{For} and 
\ident{Bind} with the following types:
%
\begin{equation*}
\begin{array}{rcll}
\ident{asyncSeq}.\ident{For} &~:~& \ident{AsyncSeq}\,\alpha &
   \rightarrow (\alpha \rightarrow \ident{AsyncSeq}\,\beta) \rightarrow \ident{AsyncSeq}\,\beta\\
\ident{asyncSeq}.\ident{Bind} &~:~& \ident{Async}\,\alpha   &
   \rightarrow (\alpha \rightarrow \ident{AsyncSeq}\,\beta) \rightarrow \ident{AsyncSeq}\,\beta\\
\end{array}
\end{equation*}
%
We omit the translation of the above example -- it is a straightforward variation on what we have 
seen so far. A more important point is that we can again benefit from the fact that operations
of the computation builder are not restricted to a specific type (such as \emph{Bind} for some
monad $M$).

As previously, the choice of the syntax is left to the author of the computation. Here, asynchronous
sequences are an additive monad and so we use \ident{for}/\ident{yield}. Underlying
asynchronous workflows are just monads, so it makes sense to add \ident{let!} that automatically
lifts a workflow to an asynchronous sequence.

An important aspect of realization that asynchronous sequences can be described using a monad
transformer means that certain laws hold. In \S\ref{sec:laws-transf} we show how these map to the 
computation expression syntax.

% --------------------------------------------------------------------------------------------------

\subsection{Applicative formlets}
\label{sec:intro-formlets}

Our last example uses a computation based on \emph{applicative functors} [2], which is a weaker
(and thus more common) abstraction than monads. The difference between applicative and monadic
computations is that monadic computation can perform different effects depending on values
obtained earlier during the computation. On the other hand, the structure of effects of applicative
computation is fully determined by its structure. 

In other words, it is not possible to choose which computation to run (using \ident{let!} or 
\ident{do!}) based on values obtained in previous \ident{let!} bindings. The following example
demonstrates this using a web form abstraction called formlets [99]:
%
\vspace{-0.3em}
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{userFormlet} = \ident{formlet}~\{\\
\quad \kvd{let!}~name = \ident{Formlet}.\ident{textBox} \\
\quad \kvd{and}~gender = \ident{Formlet}.\ident{dropDown}~[\texttt{"Male"}; \texttt{"Female"}] \\
\quad \kvd{return}~name + \texttt{" "} + gender ~\}
\end{array}
\vspace{-0.3em}
\end{equation*}
%
The computation describes two aspects -- the rendering and the processing of entered values.
The rendering phase uses the fixed structure to produce HTML with text-box and drop-down elements.
In the processing phase, the values of \emph{name} and \emph{gender} are available and are used to
calculate the result of the form.

The structure of the form needs to be known without having access to specific values. The syntax
uses parallel binding (\kvd{let!}\ldots\kvd{and}\ldots), which binds a fixed number of independent
computations. The rest of the computation cannot contain other (applicative) bindings.

There are two equivalent ways of defining applicative functors. We use the less common style
which uses two operations. \emph{Merge} of type $F\alpha \rightarrow F\beta \rightarrow F(\alpha \times \beta)$
represents composition of structure (without any knowledge of specific values) and \emph{Map} of 
type $F\alpha \rightarrow (\alpha \rightarrow \beta) \rightarrow F\beta$ transforms the (pure) value.
The computation expression from the previous example is translated as follows:
%
\vspace{-0.3em}
\begin{equation*}
\begin{array}{l}
\ident{formlet}.\ident{Map} \\
\quad (~\ident{formlet}.\ident{Merge}(\ident{Formlet}.\ident{textBox}, 
  \ident{Formlet}.\ident{dropDown}~[\texttt{"Male"}; \texttt{"Female"}]),  \\
\quad~~\kvd{fun}~(name, gender) \rightarrow name + \texttt{" "} + gender~)
\end{array}
\vspace{-0.3em}
\end{equation*}
%
The parallel binding is turned into an expression that combines all bindings using the 
\emph{Merge} operation. This part of the computation defines the structure and formlets use it
for rendering HTML. The rest of the computation is turned into a pure function passed to \emph{Map}.
Note that the translation allows uses beyond applicative functors. The \ident{let!}\ldots\ident{and}\ldots
syntax can be used with monads to write zip comprehensions [99], which are useful for
parsing, parallelism and more [99].

Applicative functors were first introduced to support \emph{applicative} programming style where
monads are not needed. The \emph{idiom brackets} notation [99] fits that purpose better. We
find that computation expressions provide a useful alternative for more complex code and fit better 
with the impure nature of F\#.

% ==================================================================================================

\section{Semantics of computation expressions}
\label{sec:semantics}

The F\# language specification [17] documents computation expressions as a purely syntactic 
mechanism. They are desugared before type-checking, which is then performed on the translated code 
using standard F\# typing rules. Similarly to Haskell's rebindable syntax [99], this provides more
flexibility and allows the users to invent previously unforseen abstractions.

In this paper, we look at computation expressions from a different perspective. We relate them to 
standard abstract computation types. In \S\ref{sec:semantics-typing}, we present a new typing that 
captures such common uses and would make the system more robust by supporting better error messages 
and disallowing non-standard uses.

% --------------------------------------------------------------------------------------------------

\subsection{Syntax}
\label{sec:semantics-syntax}

The full syntax of computation expressions is given in the language specification, but the following
lists all important constructs that we consider in this paper:
%
\begin{equation*}
\begin{array}{lclcl}
\expr  &=& \expr ~\{~ \cexpr ~\}                       &\quad&\textnormal{(computation expression)}\\
\binds &=& v=\expr                                          &&\textnormal{(single binding)}\\
       &|& v=\expr ~\kvd{and}~\binds                        &&\textnormal{(parallel binding)}\\
\cexpr &=& \kvd{let}~v=\expr~\kvd{in}~\cexpr                &&\textnormal{(binding value)} \\
       &|& \kvd{let!}~\binds~\kvd{in}~\cexpr                &&\textnormal{(binding computation)} \\
       &|& \kvd{for}~v~\kvd{in}~\expr~\kvd{do}~\cexpr       &&\textnormal{(for loop computation)} \\
       &|& \kvd{return}~\expr                               &&\textnormal{(return value)} \\
       &|& \kvd{return!}~\expr                              &&\textnormal{(return computation)} \\
       &|& \kvd{yield}~\expr                                &&\textnormal{(yield value)} \\
       &|& \kvd{yield!}~\expr                               &&\textnormal{(yield computation)} \\
       &|& \cexpr_1; \cexpr_2                               &&\textnormal{(compose computations)} \\       
       &|& \expr                                            &&\textnormal{(effectful expression)} \\
\end{array}
\end{equation*}
%
We do not include \ident{do!} which can be easily expressed in terms of the \ident{let!} construct. 
To accommodate the applicative syntax, we use a syntactic category \binds\; to express one or more
variable bindings. 

For space reasons, we also omit imperative \ident{while} and exception handling 
constructs. Both of these are an important part of computation expressions. The design principle is 
that the user should be able to wrap any valid F\# code in a computation block and augment it with 
non-standard computational aspect, while preserving the semantics (including exception handling).

% --------------------------------------------------------------------------------------------------

\begin{figure}[t!]
\begin{equation*}\hspace{-2em}
\begin{array}{rl}
\multicolumn{2}{c}{
  \boxed{\Gamma \vdash \expr :\tau}\quad\textnormal{and}\quad
    \boxed{\Gamma \bvdash \binds : \mtyp\Sigma}
}\\[1.5em]
%
(\textnormal{run})~
\inference
  { \Gamma \vdash \expr : \sigma  & \Gamma \cvdash \cexpr : \mtyp{\tau} }
  { \Gamma \vdash \expr ~\{~ \cexpr ~\} : \ntyp \tau }
&\quad\begin{array}{l}
(\forall \alpha: \sigma.\plc{Run}~:~\dtyp{\alpha} \rightarrow \ntyp \alpha \\
\;\,\forall\alpha: \sigma.\plc{Delay} : (\unit \rightarrow \mtyp{\alpha}) \rightarrow \dtyp{\alpha} )
\end{array}
\\[1.5em]
(\textnormal{bind-one})~
\inference 
  { \Gamma \vdash \expr : \mtyp{\tau} }
  { \Gamma \bvdash v=\expr : \mtyp{(\tya{v}{\tau})} }
\\[1.5em]
(\textnormal{bind-par})~
\inference 
  { \Gamma \vdash \expr : \tau & \Gamma \bvdash \binds : \mtyp{\Sigma} }
  { \Gamma \bvdash v=\expr~\kvd{and}~\binds : \mtyp{(\Sigma, \tya{v}{\tau})}  }
&\quad\begin{array}{l}
(\forall\alpha,\beta: \sigma.\plc{Merge}~:\\
\quad \mtyp{\alpha} \rightarrow \mtyp{\beta} \rightarrow \mtyp{(\alpha \times \beta)} )  
\end{array}
\\[1.5em]
%
\multicolumn{2}{c}{
  \boxed{\Gamma \cvdash \cexpr : \mtyp\tau}
}\\[1.5em]
%
(\textnormal{let})~
\inference
  { \Gamma \vdash \expr : \tau_1 &
    \Gamma, \tya{v}{\tau_1} \cvdash \cexpr : \mtyp{\tau_2} }
  { \Gamma \cvdash \kvd{let}~v=\expr~\kvd{in}~\cexpr : \mtyp{\tau_2}  }
\\[1.5em]
(\textnormal{bind})~
\inference
  { \Gamma \bvdash \binds : \mtyp\Sigma &
    \Gamma, \Sigma \cvdash \cexpr : \ntyp{\tau} }
  { \Gamma \cvdash \kvd{let!}~\binds~\kvd{in}~\cexpr : \ntyp{\tau}  }
&\quad\begin{array}{l}
(\forall\alpha,\beta: \sigma.\plc{Bind}~:\\
\quad \mtyp{\alpha} \rightarrow (\alpha \rightarrow \ntyp{\beta}) \rightarrow \ntyp{\beta} )  
\end{array}
\\[1.5em]
(\textnormal{map})~
\inference
  { \Gamma \bvdash \binds : \mtyp\Sigma &
    \Gamma, \Sigma \vdash \expr : \tau }
  { \Gamma \cvdash \kvd{let!}~\binds~\kvd{in}~\kvd{return}~\expr : \ntyp{\tau}  }
&\quad\begin{array}{l}
(\forall\alpha,\beta: \sigma.\plc{Map}~:\\
\quad \mtyp{\alpha} \rightarrow (\alpha \rightarrow \beta) \rightarrow \ntyp{\beta} )  
\end{array}
\\[1.5em]
(\textnormal{for})~
\inference
  { \Gamma \vdash \expr : \mtyp{\tau_1} &
    \Gamma, \tya{v}{\tau_1} \cvdash \cexpr : \ntyp{\tau_2} }
  { \Gamma \cvdash \kvd{for}~v~\kvd{in}~\expr~\kvd{do}~\cexpr : \ntyp{\tau_2}  }
&\quad\begin{array}{l}
(\forall\alpha,\beta: \sigma.\plc{For}~:\\
\quad \mtyp{\alpha} \rightarrow (\alpha \rightarrow \ntyp{\beta}) \rightarrow \ntyp{\beta} )  
\end{array}
\\[1.5em]
(\textnormal{return-val})~
\inference
  { \Gamma \vdash \expr : \tau }
  { \Gamma \cvdash \kvd{return}~\expr : \mtyp{\tau}  }
&\quad(\forall\alpha: \sigma.\plc{Return}~:~\alpha \rightarrow \mtyp{\alpha})
\\[1.5em]
(\textnormal{return-comp})~
\inference
  { \Gamma \vdash \expr : \mtyp \tau }
  { \Gamma \cvdash \kvd{return!}~\expr : \ntyp{\tau}  }
&\quad(\forall\alpha: \sigma.\plc{ReturnFrom}~:~\mtyp{\alpha} \rightarrow \ntyp{\alpha})  
\\[1.5em]
(\textnormal{seq})~
\inference
  { \Gamma \cvdash \cexpr_1 : \mtyp{\tau_1}  &  \Gamma \cvdash \cexpr_2 : \ntyp{\tau_2}}
  { \Gamma \cvdash \cexpr_1; \cexpr_2 : \ltyp{\tau_1}  }
&\quad\begin{array}{l}
(\forall\alpha: \sigma.\plc{Delay} ~:~ (\unit \rightarrow \ntyp{\alpha}) \rightarrow \dtyp{\alpha} \\
\;\,\forall\alpha: \sigma.\plc{Combine} : \mtyp{\tau_1} \rightarrow \dtyp{\alpha} \rightarrow \ltyp{\alpha} )
\end{array}
\\[1.5em]
(\textnormal{zero})~
\inference
  { \Gamma \vdash \expr : \unit }
  { \Gamma \cvdash \expr : \mtyp{\tau}  }
&\quad(\sigma.\plc{Zero}~:~\unit \rightarrow \mtyp{\tau})
\end{array}
\end{equation*}
\vspace{-1em}
\caption{Typing rules for computation expressions}
\label{fig:typing}
\vspace{-1em}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Typing}
\label{sec:semantics-typing}

The typing rules in Figure~\ref{fig:typing} are written using three judgments. Standard F\# 
expressions are typed using $\Gamma \vdash \expr : \tau$. Computation expressions always return
computation of type $\mtyp{\tau}$ and are typed using $\Gamma \cvdash \cexpr : \mtyp{\tau}$.
Finally, we use a helper judgement $\Gamma \bvdash \binds : \mtyp{\Sigma}$ to check bindings
of multiple computations. The judgement produces a variable context with newly bound variables, 
wrapped in the type $M$ of the bound computations.

The latter two are parameterized by the type of the computation expression builder (such as
\ident{seq} or \ident{async}). The operations supported by the builder determine which syntactic
constructs are enabled. Typing rules that require a certain operation have a side-condition
on the right, which specifies the requirement.

In most of the side-conditions, the functions are universally quantified over the type of values
(written as $\alpha, \beta$). This captures the fact that computation should not restrict the 
values that users can work with. However, this is not the case in the rules (\emph{seq}) and 
(\emph{zero}). Here, we can only require that a specific instantiation is available -- the reason 
is that these operations may be used in two different ways. As discussed in \S\ref{sec:intro-async}, 
for monads the result of \emph{Zero} and the first argument of \emph{Combine} are restricted to
$M\,\ident{unit}$. They can be universally quantified only if the computation is monoidal 
\S\ref{sec:intro-seq-parsers}.

Another notable aspect of the typing is that a single computation expression may use multiple
computation types (written $M, N, L$ and $D$). In \emph{Bind} and \emph{For}, the type of bound
argument is $M$, but the resulting computation is $N$ (we require that bind returns the same
type of computation as the one produced by the function). This corresponds to the typing used
by computations arising from monad transformers \S\ref{sec:intro-asyncseq}. Although combining
multiple computation types is not as frequent, computations often have a delayed version which
we write as $D$. This is an important consideration for impure langauges such as F\# 
\S\ref{sec:semantics-delayed}.

Finally, we omitted typing for \ident{yield} and \ident{yield!} because it is similar to the 
typing of \ident{return} and \ident{return!} (using \emph{Yield} and \emph{YieldFrom} operations,
respectively).

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\begin{equation*}
\hspace{-1em}\begin{array}{rcl}
\expr ~\{~ \cexpr ~\} &~=~& \kvd{let}~m = \expr ~\kvd{in}~m.\ident{Run}(m.\ident{Delay}(\kvd{fun}~() \rightarrow \tsl{\cexpr}))
\\[0.7em]
\tsl{\kvd{let}~v=\expr~\kvd{in}~\cexpr}          &=& \kvd{let}~v=\expr~\kvd{in}~\tsl{\cexpr} \\[0.1em]
\tsl{\kvd{let!}~\binds~\kvd{in}~\cexpr}          &=& m.\ident{Bind}(\tsb{\binds},\kvd{fun}~\tsv{\binds}\rightarrow \tsl{\cexpr}) \\[0.1em]
\tsl{\kvd{let!}~\binds~\kvd{in}~\kvd{return}\expr}          &=&
   m.\ident{Map}(\tsb{\binds},\kvd{fun}~\tsv{\binds}\rightarrow \expr) \\[0.1em]
\tsl{\kvd{for}~v~\kvd{in}~\expr~\kvd{do}~\cexpr} &=& m.\ident{For}(\expr,\kvd{fun}~()\rightarrow \tsl{\cexpr}) \\[0.1em]
%
\tsl{\kvd{return}~\expr}   &=& m.\ident{Return}(\expr) \\[0.1em]
\tsl{\kvd{return!}~\expr}  &=& m.\ident{ReturnFrom}(\expr) \\[0.1em]
\tsl{\cexpr_1; \cexpr_2}   &=& m.\ident{Combine}(\tsl{\cexpr_1}, \;m.\ident{Delay}(\kvd{fun}~() \rightarrow \tsl{\cexpr_2} )) \\[0.1em]
\tsl{\expr}                &=& \expr; ~m.\ident{Zero}()
\\[0.7em]
\tsb{v=\expr} &=& \expr \\[0.1em]
\tsb{v=\expr ~\kvd{and}~\binds} &=& m.\ident{Merge}(\expr, \tsl{\binds})
\\[0.7em]
\tsv{v=\expr} &=& v \\[0.1em]
\tsv{v=\expr ~\kvd{and}~\binds} &=& v, \tsv{\binds} 
\end{array}
\end{equation*}
\vspace{-1em}
\caption{Translation rules for computation expressions}
\label{fig:translation}
\vspace{-1em}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Translation}
\label{sec:semantics-transl}

Non-deterministic \ident{let!} but that's ok - monad laws

`Default Run and default Delay


% ==================================================================================================

\newpage
\subsection{Delayed computations}
\label{sec:semantics-delayed}
~
% ==================================================================================================

\section{Abstract computation types}
\label{sec:laws}
~

\subsection{Monad transformers}
\label{sec:laws-transf}
~

% ==================================================================================================

\section{Applicative computations}
\label{sec:applicative}

% ==================================================================================================

\section{Conclusions}
\label{sec:conclusions}

% ==================================================================================================

\section*{Acknowledgements}



\bibliographystyle{abbrv}
\bibliography{computation-zoo}

\appendix

\section{Bonus}




\end{document}












